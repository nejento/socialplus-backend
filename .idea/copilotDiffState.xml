<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/routes/api_fixed.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/routes/api_fixed.ts" />
              <option name="updatedContent" value="import { FastifyInstance } from &quot;fastify&quot;;&#10;//import { PrismaClient } from &quot;@prisma/client&quot;;&#10;import { PrismaClient } from &quot;../generated/client&quot;;&#10;import { Static, Type } from &quot;@sinclair/typebox&quot;;&#10;import { promises as fsPromises, constants } from 'fs';&#10;import path from &quot;node:path&quot;;&#10;import {hasPostPermission, isAuthenticated, isPostOwner, canViewContent, canViewAttachment, hasNetworkWriteAccess, canScheduleContent, canDeleteContent} from &quot;../helpers&quot;;&#10;&#10;const prisma = new PrismaClient();&#10;&#10;export const Post = Type.Object({&#10;    postId: Type.Integer(),&#10;    creatorId: Type.Integer()&#10;})&#10;export type PostType = Static&lt;typeof Post&gt;;&#10;&#10;export const NewPostContent = Type.Object({&#10;    content: Type.String()&#10;})&#10;export type NewPostContentType = Static&lt;typeof NewPostContent&gt;;&#10;&#10;export const EditPostContent = Type.Object({&#10;    contentId: Type.Integer(),&#10;    content: Type.String()&#10;})&#10;export type EditPostContentType = Static&lt;typeof EditPostContent&gt;;&#10;&#10;export const PostContent = Type.Object({&#10;    id: Type.Integer(),&#10;    postId: Type.Integer(),&#10;    content: Type.String(),&#10;    linkedNetworks: Type.Array(Type.Integer())&#10;})&#10;export type PostContentType = Static&lt;typeof PostContent&gt;;&#10;&#10;export const Attachment = Type.Object({&#10;    id: Type.Integer(),&#10;    postId: Type.Integer(),&#10;    fileName: Type.String(),&#10;    linkedNetworks: Type.Array(Type.Integer())&#10;})&#10;export type AttachmentType = Static&lt;typeof Attachment&gt;;&#10;&#10;export const LinkedContent = Type.Object({&#10;    postId: Type.Integer(),&#10;    contentId: Type.Integer(),&#10;    networkId: Type.Integer()&#10;})&#10;export type LinkedContentType = Static&lt;typeof LinkedContent&gt;;&#10;&#10;export const LinkedAttachment = Type.Object({&#10;    postId: Type.Integer(),&#10;    attachmentId: Type.Integer(),&#10;    networkId: Type.Integer()&#10;})&#10;export type LinkedAttachmentType = Static&lt;typeof LinkedAttachment&gt;;&#10;&#10;export const PaginatedPosts = Type.Object({&#10;    posts: Type.Array(Post),&#10;    pagination: Type.Object({&#10;        page: Type.Integer(),&#10;        limit: Type.Integer(),&#10;        total: Type.Integer(),&#10;        totalPages: Type.Integer()&#10;    })&#10;})&#10;export type PaginatedPostsType = Static&lt;typeof PaginatedPosts&gt;;&#10;&#10;export const PostDetail = Type.Object({&#10;    postId: Type.Integer(),&#10;    creatorId: Type.Integer(),&#10;    contents: Type.Array(PostContent),&#10;    attachments: Type.Array(Attachment),&#10;    scheduledTimes: Type.Array(Type.Object({&#10;        networkId: Type.Integer(),&#10;        contentId: Type.Integer(),&#10;        postDate: Type.Optional(Type.String()),&#10;        actualPostDate: Type.Optional(Type.String()),&#10;        networkPostId: Type.Optional(Type.String())&#10;    }))&#10;});&#10;export type PostDetailType = Static&lt;typeof PostDetail&gt;;&#10;&#10;export const ScheduleContentRequest = Type.Object({&#10;    postDate: Type.String() // ISO date string&#10;});&#10;export type ScheduleContentRequestType = Static&lt;typeof ScheduleContentRequest&gt;;&#10;&#10;interface IReply {&#10;    200: { success: boolean; message: string };&#10;    302: { url: string };&#10;    400: { error: string };&#10;    401: { error: string };&#10;    '4xx': { error: string };&#10;    '5xx': { error: string };&#10;}&#10;&#10;async function routes (fastify: FastifyInstance /*, options: any*/) {&#10;&#10;    // Create a new post&#10;    fastify.post&lt;{ Reply: PostType | IReply}&gt;(&#10;        '/post/create',&#10;        {&#10;            preValidation: isAuthenticated,&#10;            schema: {&#10;                description: 'Create a new post',&#10;                tags: ['post'],&#10;                response: {&#10;                    200: Post&#10;                },&#10;            },&#10;        },&#10;        async (request, reply) =&gt; {&#10;            const post = await prisma.post.create({&#10;                data: {&#10;                    creator_id: request.session.userId!,&#10;                },&#10;            });&#10;            reply.status(200).send({&#10;                postId: post.id,&#10;                creatorId: post.creator_id&#10;            });&#10;        }&#10;    );&#10;&#10;    // Create a Post content&#10;    fastify.post&lt;{ Params: { postId: number }, Body: NewPostContentType, Reply: PostContentType | IReply }&gt;(&#10;        '/post/:postId/newcontent',&#10;        {&#10;            preValidation: isAuthenticated,&#10;            schema: {&#10;                description: 'Create a new post content',&#10;                tags: ['post'],&#10;                body: NewPostContent,&#10;                params: Type.Object({&#10;                    postId: Type.Integer()&#10;                }),&#10;                response: {&#10;                    200: PostContent&#10;                },&#10;            },&#10;        },&#10;        async (request, reply) =&gt; {&#10;            try {&#10;                const { postId } = request.params;&#10;                const { content } = request.body;&#10;&#10;                const hasPermission = await hasPostPermission(postId, request.session.userId!);&#10;                if (!hasPermission) return reply.status(400).send({ error: 'Post not found or not authorized' });&#10;&#10;                const newContent = await prisma.content.create({&#10;                    data: {&#10;                        posts_id: postId,&#10;                        content: content&#10;                    },&#10;                });&#10;&#10;                // Get linked networks for this content&#10;                const linkedNetworks = await prisma.postedContent.findMany({&#10;                    where: {&#10;                        contents_id: newContent.id,&#10;                        posts_id: postId&#10;                    },&#10;                    select: {&#10;                        networks_id: true&#10;                    }&#10;                });&#10;&#10;                reply.status(200).send({&#10;                    id: newContent.id,&#10;                    postId: postId,&#10;                    content: content,&#10;                    linkedNetworks: linkedNetworks.map(ln =&gt; ln.networks_id)&#10;                });&#10;            } catch (e) {&#10;                fastify.log.error(e);&#10;                return reply.status(500).send({ error: 'Internal server error' });&#10;            }&#10;        }&#10;    );&#10;&#10;    // Edit post content&#10;    fastify.put&lt;{ Params: { postId: number }, Body: EditPostContentType, Reply: PostContentType | IReply }&gt;(&#10;        '/post/:postId/editcontent',&#10;        {&#10;            preValidation: isAuthenticated,&#10;            schema: {&#10;                description: 'Edit post content',&#10;                tags: ['post'],&#10;                params: Type.Object({&#10;                    postId: Type.Integer()&#10;                }),&#10;                body: EditPostContent,&#10;                response: {&#10;                    200: PostContent&#10;                },&#10;            },&#10;        },&#10;        async (request, reply) =&gt; {&#10;            try {&#10;                const { postId } = request.params;&#10;                const { contentId, content } = request.body;&#10;&#10;                const hasPermission = await hasPostPermission(postId, request.session.userId!);&#10;                if (!hasPermission) return reply.status(400).send({ error: 'Post not found or not authorized' });&#10;&#10;                // Check if the Post content exists&#10;                const postContent = await prisma.content.findFirst({&#10;                    where: {&#10;                        id: contentId&#10;                    }&#10;                });&#10;                if (!postContent) return reply.status(400).send({ error: 'Post content not found or not authorized' });&#10;&#10;                const newPost = await prisma.content.update({&#10;                    where: {&#10;                        id: contentId&#10;                    },&#10;                    data: {&#10;                        content: content&#10;                    }&#10;                });&#10;&#10;                // Get linked networks for this content&#10;                const linkedNetworks = await prisma.postedContent.findMany({&#10;                    where: {&#10;                        contents_id: contentId,&#10;                        posts_id: postId&#10;                    },&#10;                    select: {&#10;                        networks_id: true&#10;                    }&#10;                });&#10;&#10;                reply.status(200).send({&#10;                    id: newPost.id,&#10;                    postId: postId,&#10;                    content: content,&#10;                    linkedNetworks: linkedNetworks.map(ln =&gt; ln.networks_id)&#10;                });&#10;            } catch (e) {&#10;                fastify.log.error(e);&#10;                return reply.status(500).send({ error: 'Internal server error' });&#10;            }&#10;        }&#10;    );&#10;&#10;    // List users posts&#10;    fastify.get&lt;{ Querystring: { page?: number, limit?: number }, Reply: PaginatedPostsType | IReply }&gt;(&#10;        '/post/list',&#10;        {&#10;            preValidation: isAuthenticated,&#10;            schema: {&#10;                description: 'List users posts with pagination',&#10;                tags: ['post'],&#10;                querystring: Type.Object({&#10;                    page: Type.Optional(Type.Integer({ minimum: 1, default: 1 })),&#10;                    limit: Type.Optional(Type.Integer({ minimum: 1, maximum: 100, default: 10 }))&#10;                }),&#10;                response: {&#10;                    200: PaginatedPosts&#10;                },&#10;            },&#10;        },&#10;        async (request, reply) =&gt; {&#10;            const page = request.query.page || 1;&#10;            const limit = request.query.limit || 10;&#10;            const skip = (page - 1) * limit;&#10;&#10;            // Get total count for pagination&#10;            const totalPosts = await prisma.post.count({&#10;                where: {&#10;                    creator_id: request.session.userId!&#10;                }&#10;            });&#10;&#10;            const posts = await prisma.post.findMany({&#10;                where: {&#10;                    creator_id: request.session.userId!&#10;                },&#10;                skip: skip,&#10;                take: limit,&#10;                orderBy: {&#10;                    id: 'desc' // Order by newest first&#10;                }&#10;            });&#10;&#10;            const totalPages = Math.ceil(totalPosts / limit);&#10;&#10;            reply.status(200).send({&#10;                posts: posts.map(post =&gt; ({&#10;                    postId: post.id,&#10;                    creatorId: post.creator_id&#10;                })),&#10;                pagination: {&#10;                    page: page,&#10;                    limit: limit,&#10;                    total: totalPosts,&#10;                    totalPages: totalPages&#10;                }&#10;            });&#10;        }&#10;    );&#10;&#10;    // List posts contents&#10;    fastify.get&lt;{ Params: { postId: number }, Reply: PostContentType[] | IReply }&gt;(&#10;        '/post/:postId/listcontents',&#10;        {&#10;            preValidation: isAuthenticated,&#10;            schema: {&#10;                description: 'List posts contents',&#10;                tags: ['post'],&#10;                params: Type.Object({&#10;                    postId: Type.Integer()&#10;                }),&#10;                response: {&#10;                    200: Type.Array(PostContent)&#10;                },&#10;            },&#10;        },&#10;        async (request, reply) =&gt; {&#10;            const { postId } = request.params;&#10;&#10;            // Get all contents for this post&#10;            const contents = await prisma.content.findMany({&#10;                where: {&#10;                    posts_id: postId&#10;                }&#10;            });&#10;&#10;            // Filter contents based on new permission logic&#10;            const allowedContents = [];&#10;            for (const content of contents) {&#10;                const canView = await canViewContent(content.id, request.session.userId!);&#10;                if (canView) {&#10;                    // Get linked networks for this content&#10;                    const linkedNetworks = await prisma.postedContent.findMany({&#10;                        where: {&#10;                            contents_id: content.id,&#10;                            posts_id: postId&#10;                        },&#10;                        select: {&#10;                            networks_id: true&#10;                        }&#10;                    });&#10;&#10;                    allowedContents.push({&#10;                        id: content.id,&#10;                        postId: content.posts_id,&#10;                        content: content.content,&#10;                        linkedNetworks: linkedNetworks.map(ln =&gt; ln.networks_id)&#10;                    });&#10;                }&#10;            }&#10;&#10;            reply.status(200).send(allowedContents);&#10;        }&#10;    );&#10;&#10;    // Delete/Unlink Post content - REVISED IMPLEMENTATION&#10;    fastify.delete&lt;{ Params: { postId: number, contentId: number }, Querystring: { networkId?: number }, Reply: IReply }&gt;(&#10;        '/post/:postId/deletecontent/:contentId',&#10;        {&#10;            preValidation: isAuthenticated,&#10;            schema: {&#10;                description: 'Delete or unlink post content from network',&#10;                tags: ['post'],&#10;                params: Type.Object({&#10;                    postId: Type.Integer(),&#10;                    contentId: Type.Integer()&#10;                }),&#10;                querystring: Type.Object({&#10;                    networkId: Type.Optional(Type.Integer())&#10;                }),&#10;                response: {&#10;                    200: { success: true, message: Type.String() },&#10;                },&#10;            },&#10;        },&#10;        async (request, reply) =&gt; {&#10;            try {&#10;                const { postId, contentId } = request.params;&#10;                const { networkId } = request.query;&#10;                const userId = request.session.userId!;&#10;&#10;                // Check if the content exists and belongs to the post&#10;                const content = await prisma.content.findFirst({&#10;                    where: {&#10;                        id: contentId,&#10;                        posts_id: postId&#10;                    }&#10;                });&#10;                if (!content) return reply.status(400).send({ error: 'Content not found' });&#10;&#10;                // Get permission information using helper function&#10;                const permissions = await canDeleteContent(contentId, userId, networkId);&#10;&#10;                // If user is post creator, they can delete completely&#10;                if (permissions.canDelete) {&#10;                    // Check if content is linked to any networks&#10;                    const linkedNetworks = await prisma.postedContent.findMany({&#10;                        where: {&#10;                            contents_id: contentId,&#10;                            posts_id: postId&#10;                        }&#10;                    });&#10;&#10;                    if (linkedNetworks.length &gt; 0) {&#10;                        // Delete all network links first&#10;                        await prisma.postedContent.deleteMany({&#10;                            where: {&#10;                                contents_id: contentId,&#10;                                posts_id: postId&#10;                            }&#10;                        });&#10;                    }&#10;&#10;                    // Delete the content completely&#10;                    await prisma.content.delete({&#10;                        where: {&#10;                            id: contentId&#10;                        }&#10;                    });&#10;&#10;                    return reply.status(200).send({ &#10;                        success: true, &#10;                        message: 'Content deleted completely' &#10;                    });&#10;                }&#10;&#10;                // If not post creator, check if they can unlink from specific network&#10;                if (networkId &amp;&amp; permissions.canUnlink) {&#10;                    // Check if content is actually linked to this network&#10;                    const networkLink = await prisma.postedContent.findFirst({&#10;                        where: {&#10;                            contents_id: contentId,&#10;                            posts_id: postId,&#10;                            networks_id: networkId&#10;                        }&#10;                    });&#10;&#10;                    if (!networkLink) {&#10;                        return reply.status(400).send({ &#10;                            error: 'Content is not linked to this network' &#10;                        });&#10;                    }&#10;&#10;                    // Check how many networks this content is linked to&#10;                    const allLinks = await prisma.postedContent.findMany({&#10;                        where: {&#10;                            contents_id: contentId,&#10;                            posts_id: postId&#10;                        }&#10;                    });&#10;&#10;                    if (allLinks.length === 1) {&#10;                        // If this is the only network link, delete the content completely&#10;                        await prisma.postedContent.deleteMany({&#10;                            where: {&#10;                                contents_id: contentId,&#10;                                posts_id: postId,&#10;                                networks_id: networkId&#10;                            }&#10;                        });&#10;&#10;                        await prisma.content.delete({&#10;                            where: {&#10;                                id: contentId&#10;                            }&#10;                        });&#10;&#10;                        return reply.status(200).send({ &#10;                            success: true, &#10;                            message: 'Content removed from network and deleted (was last link)' &#10;                        });&#10;                    } else {&#10;                        // Unlink from this network only&#10;                        await prisma.postedContent.deleteMany({&#10;                            where: {&#10;                                contents_id: contentId,&#10;                                posts_id: postId,&#10;                                networks_id: networkId&#10;                            }&#10;                        });&#10;&#10;                        return reply.status(200).send({ &#10;                            success: true, &#10;                            message: 'Content unlinked from network' &#10;                        });&#10;                    }&#10;                }&#10;&#10;                // If no networkId provided but user is not post creator&#10;                if (!networkId &amp;&amp; !permissions.canDelete) {&#10;                    return reply.status(400).send({ &#10;                        error: 'You must specify networkId to unlink content from specific network' &#10;                    });&#10;                }&#10;&#10;                // User has no permission to delete or unlink&#10;                return reply.status(403).send({ &#10;                    error: 'You do not have permission to delete or unlink this content' &#10;                });&#10;&#10;            } catch (e) {&#10;                fastify.log.error(e);&#10;                return reply.status(500).send({ error: 'Internal server error' });&#10;            }&#10;        }&#10;    );&#10;&#10;    // Delete post (if it is not posted already)&#10;    fastify.delete&lt;{ Params: { postId: number }, Reply: IReply }&gt;(&#10;        '/post/:postId/delete',&#10;        {&#10;            preValidation: isAuthenticated,&#10;            schema: {&#10;                description: 'Delete post',&#10;                tags: ['post'],&#10;                params: Type.Object({&#10;                    postId: Type.Integer()&#10;                }),&#10;                response: {&#10;                    200: { success: true, message: Type.String() },&#10;                },&#10;            },&#10;        },&#10;        async (request, reply) =&gt; {&#10;            const { postId } = request.params;&#10;&#10;            const hasPermission = await hasPostPermission(postId, request.session.userId!);&#10;            if (!hasPermission) return reply.status(400).send({ error: 'Post not found or not authorized' });&#10;&#10;            // Check if the post is already posted&#10;            const postedContent = await prisma.postedContent.findFirst({&#10;                where: {&#10;                    posts_id: postId,&#10;                    NOT: {&#10;                        post_date: null&#10;                    }&#10;                }&#10;            })&#10;            if (postedContent) return reply.status(400).send({ error: 'Post cannot be deleted as it is already posted' });&#10;&#10;            // Delete the post&#10;            await prisma.post.delete({&#10;                where: {&#10;                    id: postId&#10;                }&#10;            });&#10;            reply.status(200).send({ success: true, message: 'Post deleted' });&#10;        }&#10;    );&#10;&#10;    // ... (rest of the endpoints would continue here)&#10;}&#10;&#10;export default routes;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/social/SimpleFacebookPhotoSender.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/social/SimpleFacebookPhotoSender.ts" />
              <option name="originalContent" value="import { PrismaClient } from &quot;../generated/client&quot;;&#10;&#10;// Facebook API response types&#10;interface FacebookPageTestResponse {&#10;    id?: string;&#10;    name?: string;&#10;    error?: {&#10;        message: string;&#10;        code: number;&#10;        type: string;&#10;        error_subcode?: number;&#10;    };&#10;}&#10;&#10;interface FacebookPhotoUploadResponse {&#10;    id?: string;&#10;    post_id?: string;&#10;    error?: {&#10;        message: string;&#10;        code: number;&#10;        type: string;&#10;        error_subcode?: number;&#10;    };&#10;}&#10;&#10;/**&#10; * Simple Facebook photo sender for testing purposes&#10; * This bypasses the complex provider system to test basic Facebook API functionality&#10; */&#10;export class SimpleFacebookPhotoSender {&#10;&#10;    /**&#10;     * Create a minimal black square image as Buffer&#10;     */&#10;    private createBlackSquareImage(): Buffer {&#10;        // Create a minimal 1x1 black PNG image&#10;        const pngData = Buffer.from([&#10;            0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A, // PNG signature&#10;            0x00, 0x00, 0x00, 0x0D, // IHDR chunk length&#10;            0x49, 0x48, 0x44, 0x52, // IHDR&#10;            0x00, 0x00, 0x00, 0x01, // Width: 1&#10;            0x00, 0x00, 0x00, 0x01, // Height: 1&#10;            0x08, 0x02, // Bit depth: 8, Color type: 2 (RGB)&#10;            0x00, 0x00, 0x00, // Compression, filter, interlace&#10;            0x90, 0x77, 0x53, 0xDE, // CRC&#10;            0x00, 0x00, 0x00, 0x0C, // IDAT chunk length&#10;            0x49, 0x44, 0x41, 0x54, // IDAT&#10;            0x08, 0x99, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00,&#10;            0x01, 0x00, 0x00, 0x00, 0x05, // IDAT data (black pixel)&#10;            0x27, 0xDE, 0x86, 0x19, // CRC&#10;            0x00, 0x00, 0x00, 0x00, // IEND chunk length&#10;            0x49, 0x45, 0x4E, 0x44, // IEND&#10;            0xAE, 0x42, 0x60, 0x82  // CRC&#10;        ]);&#10;&#10;        return pngData;&#10;    }&#10;&#10;    /**&#10;     * Send a photo file to Facebook page using multipart/form-data&#10;     * Following the working pattern from the browser example&#10;     * Send a photo file to Facebook page using multipart/form-data&#10;     * Following the working pattern from the browser example&#10;    async sendPhotoToFacebook(networkId: number): Promise&lt;string | null&gt; {&#10;    async sendPhotoToFacebook(networkId: number): Promise&lt;string | null&gt; {&#10;        console.log(`[SimpleFacebookSender] ${timestamp} - Starting simple Facebook photo send for network ${networkId}`);&#10;        console.log(`[SimpleFacebookSender] ${timestamp} - Starting simple Facebook photo send for network ${networkId}`);&#10;        try {&#10;            // Get tokens from database&#10;            console.log(`[SimpleFacebookSender] Fetching tokens for network ${networkId}...`);&#10;            const networkTokens = await prisma.networkToken.findMany({&#10;                where: {&#10;                    network_id: networkId&#10;                }&#10;            });&#10;&#10;            if (networkTokens.length === 0) {&#10;                console.error(`[SimpleFacebookSender] No tokens found for network ${networkId}`);&#10;                return null;&#10;            }&#10;&#10;            console.log(`[SimpleFacebookSender] Found ${networkTokens.length} tokens:`);&#10;            console.log(`[SimpleFacebookSender] Found ${networkTokens.length} tokens:`);&#10;            networkTokens.forEach(token =&gt; {&#10;                console.log(`[SimpleFacebookSender] - ${token.token_name}: ${token.token.substring(0, 20)}...`);&#10;                console.log(`[SimpleFacebookSender] - ${token.token_name}: ${token.token.substring(0, 20)}...`);&#10;                tokens[token.token_name] = token.token;&#10;            });&#10;&#10;            // Check required tokens - we need page token&#10;            const pageAccessToken = tokens.pageAccessToken;&#10;            const pageId = tokens.pageId;&#10;&#10;            console.log(`[SimpleFacebookSender] Page ID: &quot;${pageId}&quot;`);&#10;            console.log(`[SimpleFacebookSender] Page Access Token length: ${pageAccessToken?.length || 0}`);&#10;            console.log(`[SimpleFacebookSender] Page Access Token preview: ${pageAccessToken?.substring(0, 30)}...`);&#10;&#10;            if (!pageAccessToken || !pageId) {&#10;                console.error(`[SimpleFacebookSender] Missing required tokens:`);&#10;                console.error(`[SimpleFacebookSender] - pageAccessToken: ${!!pageAccessToken}`);&#10;                console.error(`[SimpleFacebookSender] - pageId: ${!!pageId}`);&#10;                return null;&#10;            }&#10;&#10;            // Validate pageId is not invalid&#10;            if (pageId === '0' || pageId.toString() === '0' || pageId.trim() === '') {&#10;                console.error(`[SimpleFacebookSender] CRITICAL: Invalid page ID detected: &quot;${pageId}&quot;`);&#10;            console.log(`[SimpleFacebookSender] Page Access Token preview: ${pageAccessToken?.substring(0, 30)}...`);&#10;&#10;            if (!pageAccessToken || !pageId) {&#10;            // Test page access first&#10;            console.log(`[SimpleFacebookSender] Testing page access...`);&#10;            const testUrl = `https://graph.facebook.com/v23.0/${pageId}?access_token=${pageAccessToken}`;&#10;                console.error(`[SimpleFacebookSender] - pageAccessToken: ${!!pageAccessToken}`);&#10;            try {&#10;                const testResponse = await fetch(testUrl);&#10;                const testResult = await testResponse.json() as FacebookPageTestResponse;&#10;                console.log(`[SimpleFacebookSender] Page test response:`, JSON.stringify(testResult, null, 2));&#10;&#10;                if (!testResponse.ok) {&#10;                    console.error(`[SimpleFacebookSender] Page test failed:`, testResult);&#10;                    return null;&#10;                }&#10;&#10;                console.log(`[SimpleFacebookSender] Page test successful! Page name: ${testResult.name || 'Unknown'}`);&#10;            } catch (testError) {&#10;                console.error(`[SimpleFacebookSender] Page test error:`, testError);&#10;                return null;&#10;            console.log(`[SimpleFacebookSender] Form data contains: source (image file), message`);&#10;&#10;            // Create black square image as fallback&#10;            console.log(`[SimpleFacebookSender] Creating black square image as fallback...`);&#10;            const imageBuffer = this.createBlackSquareImage();&#10;            console.log(`[SimpleFacebookSender] Black square image created, size: ${imageBuffer.length} bytes`);&#10;            console.log(`[SimpleFacebookSender] Authentication via page token in URL`);&#10;            // Prepare FormData for photo upload using multipart/form-data&#10;            console.log(`[SimpleFacebookSender] Preparing FormData for multipart/form-data upload...`);&#10;            console.log(`[SimpleFacebookSender] Sending multipart/form-data photo to Facebook...`);&#10;&#10;            const uploadResponse = await fetch(uploadUrl, {&#10;            // Add the image file as 'source' parameter (Facebook expects this field name)&#10;                body: form&#10;                filename: 'test-black-square.png',&#10;                contentType: 'image/png'&#10;            const uploadResult = await uploadResponse.json() as FacebookPhotoUploadResponse;&#10;            console.log(`[SimpleFacebookSender] Upload response status: ${uploadResponse.status}`);&#10;            console.log(`[SimpleFacebookSender] Upload response:`, JSON.stringify(uploadResult, null, 2));&#10;            form.append('message', 'Test post from SimpleFacebookPhotoSender - Black square image via multipart upload');&#10;            if (!uploadResponse.ok) {&#10;            // Upload URL with page token in URL for authentication&#10;&#10;            console.log(`[SimpleFacebookSender] Upload URL: ${uploadUrl}`);&#10;            console.log(`[SimpleFacebookSender] Form data contains: source (image file), message`);&#10;            console.log(`[SimpleFacebookSender] Authentication via page token in URL`);&#10;                if (uploadResult.error) {&#10;            // Make the request using multipart/form-data&#10;            console.log(`[SimpleFacebookSender] Sending multipart/form-data photo to Facebook...`);&#10;&#10;                    console.error(`[SimpleFacebookSender] - Message: ${uploadResult.error.message}`);&#10;                    console.error(`[SimpleFacebookSender] - Code: ${uploadResult.error.code}`);&#10;                    console.error(`[SimpleFacebookSender] - Type: ${uploadResult.error.type}`);&#10;                    console.error(`[SimpleFacebookSender] - Subcode: ${uploadResult.error.error_subcode}`);&#10;                }&#10;&#10;            console.log(`[SimpleFacebookSender] Upload response status: ${uploadResponse.status}`);&#10;            console.log(`[SimpleFacebookSender] Upload response:`, JSON.stringify(uploadResult, null, 2));&#10;&#10;            const photoId = uploadResult.id;&#10;            const postId = uploadResult.post_id;&#10;&#10;                // Log detailed error information&#10;                if (uploadResult.error) {&#10;                    console.error(`[SimpleFacebookSender] Error details:`);&#10;                    console.error(`[SimpleFacebookSender] - Message: ${uploadResult.error.message}`);&#10;                    console.error(`[SimpleFacebookSender] - Code: ${uploadResult.error.code}`);&#10;                    console.error(`[SimpleFacebookSender] - Type: ${uploadResult.error.type}`);&#10;                    console.error(`[SimpleFacebookSender] - Subcode: ${uploadResult.error.error_subcode}`);&#10;                }&#10;&#10;&#10;            console.log(`[SimpleFacebookSender] SUCCESS! Photo uploaded via multipart/form-data:`);&#10;            console.log(`[SimpleFacebookSender] - Photo ID: ${photoId}`);&#10;            console.log(`[SimpleFacebookSender] - Post ID: ${postId}`);&#10;            const postId = uploadResult.post_id;&#10;            return postId || photoId || null;&#10;            console.log(`[SimpleFacebookSender] SUCCESS! Photo uploaded via multipart/form-data:`);&#10;            console.log(`[SimpleFacebookSender] - Photo ID: ${photoId}`);&#10;            console.log(`[SimpleFacebookSender] - Post ID: ${postId}`);&#10;&#10;            return postId || photoId || null;&#10;            console.error(`[SimpleFacebookSender] Error during photo upload:`, error);&#10;            console.error(`[SimpleFacebookSender] Error stack:`, error instanceof Error ? error.stack : 'No stack trace');&#10;            console.error(`[SimpleFacebookSender] Error during photo upload:`, error);&#10;            console.error(`[SimpleFacebookSender] Error stack:`, error instanceof Error ? error.stack : 'No stack trace');&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="import { PrismaClient } from &quot;../generated/client&quot;;&#10;import { promises as fsPromises } from 'fs';&#10;import path from 'path';&#10;&#10;const prisma = new PrismaClient();&#10;&#10;// Facebook API response types&#10;interface FacebookPageTestResponse {&#10;    id?: string;&#10;    name?: string;&#10;    error?: {&#10;        message: string;&#10;        code: number;&#10;        type: string;&#10;        error_subcode?: number;&#10;    };&#10;}&#10;&#10;interface FacebookPhotoUploadResponse {&#10;    id?: string;&#10;    post_id?: string;&#10;    error?: {&#10;        message: string;&#10;        code: number;&#10;        type: string;&#10;        error_subcode?: number;&#10;    };&#10;}&#10;&#10;/**&#10; * Simple Facebook photo sender for testing purposes&#10; * This bypasses the complex provider system to test basic Facebook API functionality&#10; */&#10;export class SimpleFacebookPhotoSender {&#10;&#10;    /**&#10;     * Create a minimal black square image as Buffer&#10;     */&#10;    private createBlackSquareImage(): Buffer {&#10;        // Create a minimal 1x1 black PNG image&#10;        const pngData = Buffer.from([&#10;            0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A, // PNG signature&#10;            0x00, 0x00, 0x00, 0x0D, // IHDR chunk length&#10;            0x49, 0x48, 0x44, 0x52, // IHDR&#10;            0x00, 0x00, 0x00, 0x01, // Width: 1&#10;            0x00, 0x00, 0x00, 0x01, // Height: 1&#10;            0x08, 0x02, // Bit depth: 8, Color type: 2 (RGB)&#10;            0x00, 0x00, 0x00, // Compression, filter, interlace&#10;            0x90, 0x77, 0x53, 0xDE, // CRC&#10;            0x00, 0x00, 0x00, 0x0C, // IDAT chunk length&#10;            0x49, 0x44, 0x41, 0x54, // IDAT&#10;            0x08, 0x99, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00,&#10;            0x01, 0x00, 0x00, 0x00, 0x05, // IDAT data (black pixel)&#10;            0x27, 0xDE, 0x86, 0x19, // CRC&#10;            0x00, 0x00, 0x00, 0x00, // IEND chunk length&#10;            0x49, 0x45, 0x4E, 0x44, // IEND&#10;            0xAE, 0x42, 0x60, 0x82  // CRC&#10;        ]);&#10;&#10;        return pngData;&#10;    }&#10;&#10;    /**&#10;     * Send a photo file to Facebook page using actual uploaded files from the post&#10;     */&#10;    async sendPhotoToFacebook(networkId: number, postId?: number): Promise&lt;string | null&gt; {&#10;        const timestamp = new Date().toISOString();&#10;        console.log(`[SimpleFacebookSender] ${timestamp} - Starting Facebook photo send for network ${networkId}, post ${postId || 'none'}`);&#10;&#10;        try {&#10;            // Get tokens from database&#10;            console.log(`[SimpleFacebookSender] Fetching tokens for network ${networkId}...`);&#10;            const networkTokens = await prisma.networkToken.findMany({&#10;                where: {&#10;                    network_id: networkId&#10;                }&#10;            });&#10;&#10;            if (networkTokens.length === 0) {&#10;                console.error(`[SimpleFacebookSender] No tokens found for network ${networkId}`);&#10;                return null;&#10;            }&#10;&#10;            console.log(`[SimpleFacebookSender] Found ${networkTokens.length} tokens`);&#10;            const tokens: Record&lt;string, string&gt; = {};&#10;            networkTokens.forEach(token =&gt; {&#10;                tokens[token.token_name] = token.token;&#10;            });&#10;&#10;            // Check required tokens&#10;            const pageAccessToken = tokens.pageAccessToken;&#10;            const pageId = tokens.pageId;&#10;&#10;            if (!pageAccessToken || !pageId || pageId === '0') {&#10;                console.error(`[SimpleFacebookSender] Missing or invalid tokens`);&#10;                return null;&#10;            }&#10;&#10;            console.log(`[SimpleFacebookSender] Using page ID: ${pageId}`);&#10;&#10;            // Try to find an actual image file from the post if postId provided&#10;            let imageBuffer: Buffer;&#10;            let filename: string;&#10;            let contentType: string;&#10;&#10;            if (postId) {&#10;                console.log(`[SimpleFacebookSender] Looking for attachments in post ${postId}...`);&#10;                &#10;                // Get attachments linked to this network for this post&#10;                const linkedAttachments = await prisma.postedContentAttachment.findMany({&#10;                    where: {&#10;                        posts_id: postId,&#10;                        networks_id: networkId&#10;                    },&#10;                    include: {&#10;                        attachments: true&#10;                    }&#10;                });&#10;&#10;                if (linkedAttachments.length &gt; 0) {&#10;                    const attachment = linkedAttachments[0]; // Use first attachment&#10;                    const filePath = path.join(process.env.UPLOADS_DIR!, postId.toString(), path.basename(attachment.attachments.path));&#10;                    &#10;                    try {&#10;                        console.log(`[SimpleFacebookSender] Reading attachment file: ${filePath}`);&#10;                        imageBuffer = await fsPromises.readFile(filePath);&#10;                        filename = attachment.attachments.path;&#10;                        &#10;                        // Determine content type from extension&#10;                        const ext = path.extname(filename).toLowerCase();&#10;                        contentType = ext === '.png' ? 'image/png' : &#10;                                     ext === '.jpg' || ext === '.jpeg' ? 'image/jpeg' : &#10;                                     ext === '.gif' ? 'image/gif' : 'image/png';&#10;                                     &#10;                        console.log(`[SimpleFacebookSender] Using actual attachment: ${filename}, size: ${imageBuffer.length} bytes, type: ${contentType}`);&#10;                    } catch (err) {&#10;                        console.warn(`[SimpleFacebookSender] Could not read attachment file: ${filePath}, falling back to generated image`);&#10;                        imageBuffer = this.createBlackSquareImage();&#10;                        filename = 'test-black-square.png';&#10;                        contentType = 'image/png';&#10;                    }&#10;                } else {&#10;                    console.log(`[SimpleFacebookSender] No attachments found for post ${postId}, using generated image`);&#10;                    imageBuffer = this.createBlackSquareImage();&#10;                    filename = 'test-black-square.png';&#10;                    contentType = 'image/png';&#10;                }&#10;            } else {&#10;                console.log(`[SimpleFacebookSender] No post ID provided, using generated black square`);&#10;                imageBuffer = this.createBlackSquareImage();&#10;                filename = 'test-black-square.png';&#10;                contentType = 'image/png';&#10;            }&#10;&#10;            // Prepare FormData for photo upload&#10;            console.log(`[SimpleFacebookSender] Preparing multipart/form-data upload...`);&#10;            const FormData = (await import('form-data')).default;&#10;            const form = new FormData();&#10;&#10;            // Add the image file as 'source' parameter&#10;            form.append('source', imageBuffer, {&#10;                filename: filename,&#10;                contentType: contentType&#10;            });&#10;&#10;            // Add message&#10;            form.append('message', 'Test post from SimpleFacebookPhotoSender via multipart upload');&#10;&#10;            // Upload URL&#10;            const uploadUrl = `https://graph.facebook.com/v23.0/${pageId}/photos?access_token=${pageAccessToken}`;&#10;            console.log(`[SimpleFacebookSender] Uploading to: ${uploadUrl}`);&#10;&#10;            // Make the request&#10;            const uploadResponse = await fetch(uploadUrl, {&#10;                method: 'POST',&#10;                body: form&#10;            });&#10;&#10;            const uploadResult = await uploadResponse.json() as FacebookPhotoUploadResponse;&#10;            console.log(`[SimpleFacebookSender] Response status: ${uploadResponse.status}`);&#10;            console.log(`[SimpleFacebookSender] Response:`, JSON.stringify(uploadResult, null, 2));&#10;&#10;            if (!uploadResponse.ok) {&#10;                console.error(`[SimpleFacebookSender] Upload failed:`, uploadResult);&#10;                return null;&#10;            }&#10;&#10;            const photoId = uploadResult.id;&#10;            const networkPostId = uploadResult.post_id;&#10;&#10;            console.log(`[SimpleFacebookSender] SUCCESS! Photo uploaded - Photo ID: ${photoId}, Post ID: ${networkPostId}`);&#10;            return networkPostId || photoId || null;&#10;&#10;        } catch (error) {&#10;            console.error(`[SimpleFacebookSender] Error during upload:`, error);&#10;            return null;&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>